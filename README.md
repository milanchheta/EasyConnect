# EasyConnect

## Folder Stucture

    .
    ├── backend/                            # Flask application files
    │   ├── app/
    │   │   ├── controllers/
    │   │   │   └── controllers.py          # File containing all the endpoints to handle frontend requests
    │   │   └── helpers/                    # Folder with helper functions
    │   │       ├── crawler.py              # File used to fetch data from google scholarly API
    │   │       ├── dbConfig.py             # Databse configuratinon file
    │   │       ├── researchersList.json    # JSON file consisting IU faculty data
    │   │       └── tokenizor.py            # File used for generating keywords and computing cosine similarities
    │   └── run.py                          # Flask application server
    ├── frontend/                           # Frontend application
    │   ├── Actions/                        # Folder containing Redux actions
    │   │   ├── LoginAction.js              # File for handling login actions
    │   │   ├── ProfileAction.js            # File for handling profile actions
    │   │   ├── RecommendationsAction.js    # File for handling recommendations actions
    │   │   └── RegisterAction.js           # File for handling registration actions
    │   ├── Reducers/                       # Folder containing Redux reducers
    │   │   ├── LoginReducer.js             # File for handling registration reducer functions
    │   │   ├── ProfileReducer.js           # File for handling registration reducer functions
    │   │   ├── RecommendationsReducer.js   # File for handling registration reducer functions
    │   │   ├── RegisterReducer.js          # File for handling registration reducer functions
    │   │   └── Rootreducer.js              # Root reducer file
    │   ├── components/                     # Folder with all the application components
    │   │   ├── BASE_URL.js                 # File with the BASE URL to send requests
    │   │   ├── Connections.js              # Component for showing connections page
    │   │   ├── EditProfile.js              # Component for editing profile page
    │   │   ├── Home.js                     # Component for showinf recommendations on homepage
    │   │   ├── Login.js                    # Component for login page
    │   │   ├── MessageRoom.js              # Component for chatroom page
    │   │   ├── PaperDetails.js             # Component for showing paper details page
    │   │   ├── PaperList.js                # Component for showing list of papers for a researcher
    │   │   ├── Profile.js                  # Component for showing researcher's profile page
    │   │   ├── Register.js                 # Component for registration page
    │   │   ├── Requests.js                 # Component for showing and handling conenction requests
    │   │   └── UserProfile.js              # Component for showing user's profile page
    │   ├── App.js                          # Entry file for react native application
    │   └── store.js                        # File containing Redux store configurations
    └── ui_Designs/                         # Folder containing inital UI designs

## How to run and test the application:

### Testing with hosted flask application:

Follow the below steps:

- Install the provided apk file from `apk/` folder in an android phone.
- Good to go. Now you can start using the application.
- If you find that there are no requests going through the application, please check the data permissions for the application in your device.

### Testing application on local environment:

Pre-requisites:

- Expo framework kit
- Python 3.6 and higher
- `BASE_URL` in `/frontend/components/BASE_URL.js` should be `http://10.0.2.2:5000`
- Android studio with AVD for local testing

Follow the below steps:

- Execute `npm install` in `frontend/` directory.
- Create a virtual environment for backend, executing `python3 -m venv venv`.
- Activate the virtual environment by running `source venv/bin/activate`.
- Execute `pip3 install -r rquirements.txt` in `backend/` directory.
- Execute `npm start` in `frontend/` directory.
- Execute `python3 run.py` in `backend/` directory.
- Start the android studio and the AVD for simulation
- Click on the `Run on Android device/simulator` option on local host.
- Application will start running on android simulator.

## Web Crawler Approach

We have utilized this opportunity to develop a web crawler, which we run for collecting the researcher data from Google Scholar using a pre-built list of researchers which are collected from the professors university profile. This crawler utilizes a python library named scholarly, which supports gaining access from the Google Scholar website.

The pre-built data is generated by utilizing another public web crawler, which aggregates the user name and their IU email. This is used to fetch their Google Scholar profile and all the attached data available from the Google Scholar, which fills the Scholar table in our database.

The web crawler can be set to run nightly or fortnightly depending on the profile updations scanned from the Google Scholar profile for each researcher.

## Recommendation System

The recommendation system works in two major steps.

The passive and non-repeating step is to compute the keywords associated with each researcher based on their Google Scholar profile. This step is utilized only when the google scholar data is refreshed by the web crawler.

The passive step works by calculating the bi-grams and n-grams for each research paper published by the researcher as well as the profile interests they have mentioned in their application. These are collected and their top keywords are selected as the defining research interests for each professor/ researcher.

For the active recommendation system, the user will try to edit their interests in the edit profile section or else upload a new paper of interest. Once the user has done either of these activity, a loading screen is presented to them, while in the back end the code extracts keywords from the paper the user uploaded and combines them with the user interests. These are then verified against each researcher in the database calculating the cosine similarity for each research paper for each researcher in the system.

Once this activity is completed the list of top 10 professors are returned to the application, which is displayed in the home screen under the reccommendations tab. 

The recommendations approach flushes the previous user uploaded paper keywords such that if the user shifts their area of interest, they will not be shown earlier results, as would be the case if we build on the user interests keywords.

## Code Availability

The code is made available in such a way that any user can easily access the application in their android smartphone.
To enable user interface testing in personal devices, we have enabled our backend services to be available via the internet.
The backend service is hosted in our own Luddy's personal server, namely Silo (Burrow).

The backend server is run on a seperate screen in silo, and an ngrok intermediate is used to expose the locally run http server over the internet.

Ngrok works by tunnelling the exposed localhost server port, to a globally accessible http link, which the application utilizes for rendering real time data.

React Native also utilizes the available redux functionality to maintain states and cut down the required number of server requests, unless a state change is made by the user.

## Technical future work:

We have limited the development aspects of the application based on the time constraint that we had with the application development deadline.
These are the few things that we have identified as the future steps that we can take to make this application usability a much better experience.

* Host flask application on a proper hosting website
* Implement parallel processing to improve efficiency and processing speed forgenerating  recommendations.
* Generate a IPA file for IOS application with a paid apple developer account.
* Implement features such as search engine, disccusion forums, etc.
* Testing the application user experince.
